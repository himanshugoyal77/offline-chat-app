"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/TalkingAvatar.tsx":
/*!**************************************!*\
  !*** ./components/TalkingAvatar.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nconst TalkingAvatar = (param)=>{\n    let { script } = param;\n    _s();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [talkStreamId, setTalkStreamId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const apiKey = \"ZGFua2hpbWFuc2h1QGdtYWlsLmNvbQ:3hYLN1A_zbCVMMyF-93VT\"; // Replace with your D-ID API key\n    const imageUrl = \"https://img.freepik.com/free-photo/portrait-white-man-isolated_53876-40306.jpg?semt=ais_hybrid\"; // Replace with the URL to your avatar image\n    // Store the previous scripts and their talk stream IDs to avoid duplicate API calls\n    const scriptsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({});\n    const createTalkStream = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"TalkingAvatar.useCallback[createTalkStream]\": async ()=>{\n            try {\n                // Check if the script has already been processed\n                if (scriptsCache.current[script]) {\n                    console.log(\"Script already processed:\", script);\n                    setTalkStreamId(scriptsCache.current[script]); // Use the cached talkStreamId\n                    return;\n                }\n                // Step 1: Create a new talk stream only if script is not empty\n                if (!script || script.length < 3) {\n                    throw new Error(\"Input text must be at least 3 characters long.\");\n                }\n                const response = await fetch(\"https://api.d-id.com/talks/\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        Authorization: \"Basic \".concat(btoa(apiKey + \":\"))\n                    },\n                    body: JSON.stringify({\n                        source_url: imageUrl,\n                        script: {\n                            type: \"text\",\n                            input: script,\n                            provider: {\n                                type: \"google\"\n                            }\n                        }\n                    })\n                });\n                if (!response.ok) {\n                    throw new Error(\"Failed to create talk stream\");\n                }\n                const { id } = await response.json();\n                setTalkStreamId(id); // Store the talk stream ID to trigger the next steps\n                // Cache the script and its talkStreamId\n                scriptsCache.current[script] = id;\n            } catch (error) {\n                console.error(\"Error creating talk stream:\", error);\n            }\n        }\n    }[\"TalkingAvatar.useCallback[createTalkStream]\"], [\n        script\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"TalkingAvatar.useEffect\": ()=>{\n            if (talkStreamId) {\n                const startWebRTCConnection = {\n                    \"TalkingAvatar.useEffect.startWebRTCConnection\": async ()=>{\n                        try {\n                            const offerResponse = await fetch(\"https://api.d-id.com/talks/\".concat(talkStreamId, \"/\"), {\n                                headers: {\n                                    \"Content-Type\": \"application/json\",\n                                    Authorization: \"Basic \".concat(btoa(apiKey + \":\"))\n                                }\n                            });\n                            if (!offerResponse.ok) {\n                                throw new Error(\"Failed to start WebRTC connection\");\n                            }\n                            const { sdp } = await offerResponse.json();\n                            // Create a new RTC connection and handle the SDP offer\n                            const pc = new RTCPeerConnection();\n                            // Set the remote description (SDP offer) from the response\n                            await pc.setRemoteDescription(new RTCSessionDescription({\n                                type: 'offer',\n                                sdp\n                            }));\n                            // Handle ICE candidate gathering (if necessary)\n                            pc.onicecandidate = ({\n                                \"TalkingAvatar.useEffect.startWebRTCConnection\": (event)=>{\n                                    if (event.candidate) {\n                                        // Send candidate to the server if needed\n                                        console.log('ICE Candidate: ', event.candidate);\n                                    }\n                                }\n                            })[\"TalkingAvatar.useEffect.startWebRTCConnection\"];\n                            // Play the video stream when it's available\n                            pc.ontrack = ({\n                                \"TalkingAvatar.useEffect.startWebRTCConnection\": (event)=>{\n                                    const stream = event.streams[0]; // Assuming a single stream (audio/video)\n                                    if (videoRef.current) {\n                                        videoRef.current.srcObject = stream;\n                                    }\n                                }\n                            })[\"TalkingAvatar.useEffect.startWebRTCConnection\"];\n                            // Once the connection is set up, display the video\n                            const offer = await pc.createAnswer();\n                            await pc.setLocalDescription(offer);\n                        } catch (error) {\n                            console.error(\"Error starting WebRTC connection:\", error);\n                        }\n                    }\n                }[\"TalkingAvatar.useEffect.startWebRTCConnection\"];\n                startWebRTCConnection();\n            }\n        }\n    }[\"TalkingAvatar.useEffect\"], [\n        talkStreamId\n    ]); // Only run this effect when the talk stream ID is available\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"TalkingAvatar.useEffect\": ()=>{\n            createTalkStream();\n        }\n    }[\"TalkingAvatar.useEffect\"], [\n        script,\n        createTalkStream\n    ]); // Only recreate the talk stream when the script changes\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n        ref: videoRef,\n        controls: true\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\HP\\\\OneDrive\\\\Desktop\\\\aadil\\\\TechXpression\\\\components\\\\TalkingAvatar.tsx\",\n        lineNumber: 115,\n        columnNumber: 10\n    }, undefined);\n};\n_s(TalkingAvatar, \"mrPEba6zKiI39N46kgdX8VYswVU=\");\n_c = TalkingAvatar;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TalkingAvatar);\nvar _c;\n$RefreshReg$(_c, \"TalkingAvatar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvVGFsa2luZ0F2YXRhci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlFO0FBRWpFLE1BQU1JLGdCQUFnQjtRQUFDLEVBQUVDLE1BQU0sRUFBc0I7O0lBQ25ELE1BQU1DLFdBQVdMLDZDQUFNQSxDQUFtQjtJQUMxQyxNQUFNLENBQUNNLGNBQWNDLGdCQUFnQixHQUFHTiwrQ0FBUUEsQ0FBZ0I7SUFDaEUsTUFBTU8sU0FBUyx3REFBd0QsaUNBQWlDO0lBQ3hHLE1BQU1DLFdBQ0osa0dBQWtHLDRDQUE0QztJQUVoSixvRkFBb0Y7SUFDcEYsTUFBTUMsZUFBZVYsNkNBQU1BLENBQTRCLENBQUM7SUFFeEQsTUFBTVcsbUJBQW1CVCxrREFBV0E7dURBQUM7WUFDbkMsSUFBSTtnQkFDRixpREFBaUQ7Z0JBQ2pELElBQUlRLGFBQWFFLE9BQU8sQ0FBQ1IsT0FBTyxFQUFFO29CQUNoQ1MsUUFBUUMsR0FBRyxDQUFDLDZCQUE2QlY7b0JBQ3pDRyxnQkFBZ0JHLGFBQWFFLE9BQU8sQ0FBQ1IsT0FBTyxHQUFHLDhCQUE4QjtvQkFDN0U7Z0JBQ0Y7Z0JBRUEsK0RBQStEO2dCQUMvRCxJQUFJLENBQUNBLFVBQVVBLE9BQU9XLE1BQU0sR0FBRyxHQUFHO29CQUNoQyxNQUFNLElBQUlDLE1BQU07Z0JBQ2xCO2dCQUVBLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSwrQkFBK0I7b0JBQzFEQyxRQUFRO29CQUNSQyxTQUFTO3dCQUNQLGdCQUFnQjt3QkFDaEJDLGVBQWUsU0FBNEIsT0FBbkJDLEtBQUtkLFNBQVM7b0JBQ3hDO29CQUNBZSxNQUFNQyxLQUFLQyxTQUFTLENBQUM7d0JBQ25CQyxZQUFZakI7d0JBQ1pMLFFBQVE7NEJBQ051QixNQUFNOzRCQUNOQyxPQUFPeEI7NEJBQ1B5QixVQUFVO2dDQUFFRixNQUFNOzRCQUFTO3dCQUM3QjtvQkFDRjtnQkFDRjtnQkFFQSxJQUFJLENBQUNWLFNBQVNhLEVBQUUsRUFBRTtvQkFDaEIsTUFBTSxJQUFJZCxNQUFNO2dCQUNsQjtnQkFFQSxNQUFNLEVBQUVlLEVBQUUsRUFBRSxHQUFHLE1BQU1kLFNBQVNlLElBQUk7Z0JBQ2xDekIsZ0JBQWdCd0IsS0FBSyxxREFBcUQ7Z0JBRTFFLHdDQUF3QztnQkFDeENyQixhQUFhRSxPQUFPLENBQUNSLE9BQU8sR0FBRzJCO1lBQ2pDLEVBQUUsT0FBT0UsT0FBTztnQkFDZHBCLFFBQVFvQixLQUFLLENBQUMsK0JBQStCQTtZQUMvQztRQUNGO3NEQUFHO1FBQUM3QjtLQUFPO0lBRVhMLGdEQUFTQTttQ0FBQztZQUNSLElBQUlPLGNBQWM7Z0JBQ2hCLE1BQU00QjtxRUFBd0I7d0JBQzVCLElBQUk7NEJBQ0YsTUFBTUMsZ0JBQWdCLE1BQU1qQixNQUMxQiw4QkFBMkMsT0FBYlosY0FBYSxNQUMzQztnQ0FDRWMsU0FBUztvQ0FDUCxnQkFBZ0I7b0NBQ2hCQyxlQUFlLFNBQTRCLE9BQW5CQyxLQUFLZCxTQUFTO2dDQUN4Qzs0QkFDRjs0QkFHRixJQUFJLENBQUMyQixjQUFjTCxFQUFFLEVBQUU7Z0NBQ3JCLE1BQU0sSUFBSWQsTUFBTTs0QkFDbEI7NEJBRUEsTUFBTSxFQUFFb0IsR0FBRyxFQUFFLEdBQUcsTUFBTUQsY0FBY0gsSUFBSTs0QkFFeEMsdURBQXVEOzRCQUN2RCxNQUFNSyxLQUFLLElBQUlDOzRCQUVmLDJEQUEyRDs0QkFDM0QsTUFBTUQsR0FBR0Usb0JBQW9CLENBQUMsSUFBSUMsc0JBQXNCO2dDQUFFYixNQUFNO2dDQUFTUzs0QkFBSTs0QkFFN0UsZ0RBQWdEOzRCQUNoREMsR0FBR0ksY0FBYztpRkFBRyxDQUFDQztvQ0FDbkIsSUFBSUEsTUFBTUMsU0FBUyxFQUFFO3dDQUNuQix5Q0FBeUM7d0NBQ3pDOUIsUUFBUUMsR0FBRyxDQUFDLG1CQUFtQjRCLE1BQU1DLFNBQVM7b0NBQ2hEO2dDQUNGOzs0QkFFQSw0Q0FBNEM7NEJBQzVDTixHQUFHTyxPQUFPO2lGQUFHLENBQUNGO29DQUNaLE1BQU1HLFNBQVNILE1BQU1JLE9BQU8sQ0FBQyxFQUFFLEVBQUUseUNBQXlDO29DQUMxRSxJQUFJekMsU0FBU08sT0FBTyxFQUFFO3dDQUNwQlAsU0FBU08sT0FBTyxDQUFDbUMsU0FBUyxHQUFHRjtvQ0FDL0I7Z0NBQ0Y7OzRCQUVBLG1EQUFtRDs0QkFDbkQsTUFBTUcsUUFBUSxNQUFNWCxHQUFHWSxZQUFZOzRCQUNuQyxNQUFNWixHQUFHYSxtQkFBbUIsQ0FBQ0Y7d0JBQy9CLEVBQUUsT0FBT2YsT0FBTzs0QkFDZHBCLFFBQVFvQixLQUFLLENBQUMscUNBQXFDQTt3QkFDckQ7b0JBQ0Y7O2dCQUVBQztZQUNGO1FBQ0Y7a0NBQUc7UUFBQzVCO0tBQWEsR0FBRyw0REFBNEQ7SUFFaEZQLGdEQUFTQTttQ0FBQztZQUNSWTtRQUNGO2tDQUFHO1FBQUNQO1FBQVFPO0tBQWlCLEdBQUcsd0RBQXdEO0lBRXhGLHFCQUFPLDhEQUFDd0M7UUFBTUMsS0FBSy9DO1FBQVVnRCxRQUFROzs7Ozs7QUFDdkM7R0FqSE1sRDtLQUFBQTtBQW1ITixpRUFBZUEsYUFBYUEsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxIUFxcT25lRHJpdmVcXERlc2t0b3BcXGFhZGlsXFxUZWNoWHByZXNzaW9uXFxjb21wb25lbnRzXFxUYWxraW5nQXZhdGFyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XHJcblxyXG5jb25zdCBUYWxraW5nQXZhdGFyID0gKHsgc2NyaXB0IH06IHsgc2NyaXB0OiBzdHJpbmcgfSkgPT4ge1xyXG4gIGNvbnN0IHZpZGVvUmVmID0gdXNlUmVmPEhUTUxWaWRlb0VsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IFt0YWxrU3RyZWFtSWQsIHNldFRhbGtTdHJlYW1JZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcclxuICBjb25zdCBhcGlLZXkgPSBcIlpHRnVhMmhwYldGdWMyaDFRR2R0WVdsc0xtTnZiUTozaFlMTjFBX3piQ1ZNTXlGLTkzVlRcIjsgLy8gUmVwbGFjZSB3aXRoIHlvdXIgRC1JRCBBUEkga2V5XHJcbiAgY29uc3QgaW1hZ2VVcmwgPVxyXG4gICAgXCJodHRwczovL2ltZy5mcmVlcGlrLmNvbS9mcmVlLXBob3RvL3BvcnRyYWl0LXdoaXRlLW1hbi1pc29sYXRlZF81Mzg3Ni00MDMwNi5qcGc/c2VtdD1haXNfaHlicmlkXCI7IC8vIFJlcGxhY2Ugd2l0aCB0aGUgVVJMIHRvIHlvdXIgYXZhdGFyIGltYWdlXHJcblxyXG4gIC8vIFN0b3JlIHRoZSBwcmV2aW91cyBzY3JpcHRzIGFuZCB0aGVpciB0YWxrIHN0cmVhbSBJRHMgdG8gYXZvaWQgZHVwbGljYXRlIEFQSSBjYWxsc1xyXG4gIGNvbnN0IHNjcmlwdHNDYWNoZSA9IHVzZVJlZjx7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9Pih7fSk7XHJcblxyXG4gIGNvbnN0IGNyZWF0ZVRhbGtTdHJlYW0gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgc2NyaXB0IGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkXHJcbiAgICAgIGlmIChzY3JpcHRzQ2FjaGUuY3VycmVudFtzY3JpcHRdKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTY3JpcHQgYWxyZWFkeSBwcm9jZXNzZWQ6XCIsIHNjcmlwdCk7XHJcbiAgICAgICAgc2V0VGFsa1N0cmVhbUlkKHNjcmlwdHNDYWNoZS5jdXJyZW50W3NjcmlwdF0pOyAvLyBVc2UgdGhlIGNhY2hlZCB0YWxrU3RyZWFtSWRcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFN0ZXAgMTogQ3JlYXRlIGEgbmV3IHRhbGsgc3RyZWFtIG9ubHkgaWYgc2NyaXB0IGlzIG5vdCBlbXB0eVxyXG4gICAgICBpZiAoIXNjcmlwdCB8fCBzY3JpcHQubGVuZ3RoIDwgMykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IHRleHQgbXVzdCBiZSBhdCBsZWFzdCAzIGNoYXJhY3RlcnMgbG9uZy5cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwczovL2FwaS5kLWlkLmNvbS90YWxrcy9cIiwge1xyXG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmFzaWMgJHtidG9hKGFwaUtleSArIFwiOlwiKX1gLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgICAgc291cmNlX3VybDogaW1hZ2VVcmwsXHJcbiAgICAgICAgICBzY3JpcHQ6IHtcclxuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXHJcbiAgICAgICAgICAgIGlucHV0OiBzY3JpcHQsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyOiB7IHR5cGU6IFwiZ29vZ2xlXCIgfSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgdGFsayBzdHJlYW1cIik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHsgaWQgfSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgc2V0VGFsa1N0cmVhbUlkKGlkKTsgLy8gU3RvcmUgdGhlIHRhbGsgc3RyZWFtIElEIHRvIHRyaWdnZXIgdGhlIG5leHQgc3RlcHNcclxuXHJcbiAgICAgIC8vIENhY2hlIHRoZSBzY3JpcHQgYW5kIGl0cyB0YWxrU3RyZWFtSWRcclxuICAgICAgc2NyaXB0c0NhY2hlLmN1cnJlbnRbc2NyaXB0XSA9IGlkO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNyZWF0aW5nIHRhbGsgc3RyZWFtOlwiLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfSwgW3NjcmlwdF0pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKHRhbGtTdHJlYW1JZCkge1xyXG4gICAgICBjb25zdCBzdGFydFdlYlJUQ0Nvbm5lY3Rpb24gPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IG9mZmVyUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgICAgICAgYGh0dHBzOi8vYXBpLmQtaWQuY29tL3RhbGtzLyR7dGFsa1N0cmVhbUlkfS9gLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmFzaWMgJHtidG9hKGFwaUtleSArIFwiOlwiKX1gLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgaWYgKCFvZmZlclJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBzdGFydCBXZWJSVEMgY29ubmVjdGlvblwiKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjb25zdCB7IHNkcCB9ID0gYXdhaXQgb2ZmZXJSZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IFJUQyBjb25uZWN0aW9uIGFuZCBoYW5kbGUgdGhlIFNEUCBvZmZlclxyXG4gICAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oKTtcclxuXHJcbiAgICAgICAgICAvLyBTZXQgdGhlIHJlbW90ZSBkZXNjcmlwdGlvbiAoU0RQIG9mZmVyKSBmcm9tIHRoZSByZXNwb25zZVxyXG4gICAgICAgICAgYXdhaXQgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7IHR5cGU6ICdvZmZlcicsIHNkcCB9KSk7XHJcblxyXG4gICAgICAgICAgLy8gSGFuZGxlIElDRSBjYW5kaWRhdGUgZ2F0aGVyaW5nIChpZiBuZWNlc3NhcnkpXHJcbiAgICAgICAgICBwYy5vbmljZWNhbmRpZGF0ZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQuY2FuZGlkYXRlKSB7XHJcbiAgICAgICAgICAgICAgLy8gU2VuZCBjYW5kaWRhdGUgdG8gdGhlIHNlcnZlciBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSUNFIENhbmRpZGF0ZTogJywgZXZlbnQuY2FuZGlkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAvLyBQbGF5IHRoZSB2aWRlbyBzdHJlYW0gd2hlbiBpdCdzIGF2YWlsYWJsZVxyXG4gICAgICAgICAgcGMub250cmFjayA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBldmVudC5zdHJlYW1zWzBdOyAvLyBBc3N1bWluZyBhIHNpbmdsZSBzdHJlYW0gKGF1ZGlvL3ZpZGVvKVxyXG4gICAgICAgICAgICBpZiAodmlkZW9SZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgIHZpZGVvUmVmLmN1cnJlbnQuc3JjT2JqZWN0ID0gc3RyZWFtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIC8vIE9uY2UgdGhlIGNvbm5lY3Rpb24gaXMgc2V0IHVwLCBkaXNwbGF5IHRoZSB2aWRlb1xyXG4gICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVBbnN3ZXIoKTtcclxuICAgICAgICAgIGF3YWl0IHBjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc3RhcnRpbmcgV2ViUlRDIGNvbm5lY3Rpb246XCIsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBzdGFydFdlYlJUQ0Nvbm5lY3Rpb24oKTtcclxuICAgIH1cclxuICB9LCBbdGFsa1N0cmVhbUlkXSk7IC8vIE9ubHkgcnVuIHRoaXMgZWZmZWN0IHdoZW4gdGhlIHRhbGsgc3RyZWFtIElEIGlzIGF2YWlsYWJsZVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY3JlYXRlVGFsa1N0cmVhbSgpO1xyXG4gIH0sIFtzY3JpcHQsIGNyZWF0ZVRhbGtTdHJlYW1dKTsgLy8gT25seSByZWNyZWF0ZSB0aGUgdGFsayBzdHJlYW0gd2hlbiB0aGUgc2NyaXB0IGNoYW5nZXNcclxuXHJcbiAgcmV0dXJuIDx2aWRlbyByZWY9e3ZpZGVvUmVmfSBjb250cm9scyAvPjtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRhbGtpbmdBdmF0YXI7XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiVGFsa2luZ0F2YXRhciIsInNjcmlwdCIsInZpZGVvUmVmIiwidGFsa1N0cmVhbUlkIiwic2V0VGFsa1N0cmVhbUlkIiwiYXBpS2V5IiwiaW1hZ2VVcmwiLCJzY3JpcHRzQ2FjaGUiLCJjcmVhdGVUYWxrU3RyZWFtIiwiY3VycmVudCIsImNvbnNvbGUiLCJsb2ciLCJsZW5ndGgiLCJFcnJvciIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImJ0b2EiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInNvdXJjZV91cmwiLCJ0eXBlIiwiaW5wdXQiLCJwcm92aWRlciIsIm9rIiwiaWQiLCJqc29uIiwiZXJyb3IiLCJzdGFydFdlYlJUQ0Nvbm5lY3Rpb24iLCJvZmZlclJlc3BvbnNlIiwic2RwIiwicGMiLCJSVENQZWVyQ29ubmVjdGlvbiIsInNldFJlbW90ZURlc2NyaXB0aW9uIiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwib25pY2VjYW5kaWRhdGUiLCJldmVudCIsImNhbmRpZGF0ZSIsIm9udHJhY2siLCJzdHJlYW0iLCJzdHJlYW1zIiwic3JjT2JqZWN0Iiwib2ZmZXIiLCJjcmVhdGVBbnN3ZXIiLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwidmlkZW8iLCJyZWYiLCJjb250cm9scyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/TalkingAvatar.tsx\n"));

/***/ })

});